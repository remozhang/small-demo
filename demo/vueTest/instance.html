var vm = new Vue({
	//选项
})

文档中经常会使用vm这个变量名表示Vue实例

可以扩展Vue构造器，从而预定义选项创建可复用的组件构造器

var MyConponent = Vue.extend({
	//扩展选项
})

//所有的MyComponent 实例都将以预定义的扩展选项被创建
var myComponentInstance = new MyConponent();

======================================================================

属性和方法
每个Vue实例都会代理data对象所有的属性

var data = { a: 1 }
var vm = new Vue({
	data:data
})

vm.a === data.a //-> true

//设置属性也会影响到原始数据
vm.a = 2
data.a = 2

//反之亦然
data.a = 3
vm.a // ->3

注意这些被代理的属性都是响应的。如果在实例创建之后添加新的属性到实力上，他不会触发视图更新。


var data = { a: 1}
var vm = new Vue({
	el : '#example',
	data:data
})

vm.$data === data // -> true
vm.$el ===document.getElementById('example') // ->true

//$watch是一个实例方法
vm.$watch('a',function(newVal,oldVal) {
	//这个回调将在'vm.a'改变后再调用
} )

注意 不能在实力属性或者回调函数中使用箭头函数。
因为箭头函数绑定父上下文
====================================================
实例的生命周期

var vm = new Vue({
	data: {
		a:1
	},
	//creatd这个钩子在实例被创建之后被调用
	created: function() {
		//this指向vm实例
		console.log('a is:'+this.a)
	}
})

// 'a is :1'

mounted、 updated、destroyed
钩子的this指向调用他的vue


==================================================
模版语法

文本
<span>Message:{{msg}}</span>

无论何时，绑定的数据对象上msg属性发生了改变，插值处的内容都会更新

<span v-once>This will never change: {{msg}}</span>

------------------------------------------------

纯HTML
双大括号会将数据解释为纯文本，而非HTML。为了输出真正的HTML，你需要使用v-html指令：
<div v-html="rawHtml"></div>
被插入的内容会被当作HTML----数据绑定会被忽略。

---------------------------------------------------
属性

<div v-bind:id="dynamicId"></div>

<div v-bind:disabled="someDynamicCondition"></div>


-----------------------------------------------
使用javascript表达式
{{namber +1}}
{{ok?'YES' :'NO'}}
{{message.split('').reverse().join('')}}
<div v-bind:id="'list'+id"></div>

每个绑定只能包含单个表达式

===================================================
指令
directive是带有v-前缀的特殊指令，指令属性的预期是单一js表达式（除了v-for）。指令的职责就是当表达式的值改变时相应地将某些行为应用到DOM

<p v-if="seen">Now you see me</p>

这里 v-if指令将根据seen的值的真假插入<p>元素。

--------------------------------------------------
参数

<a v-bind:href="url"></a>

href是参数，告知v-bind指令将该元素的href属性与url绑定。

<a v-on:click="doSomething"></a>

-----------------------------------------------
修饰符
<form v-on:submit.prevent="onSubmit"></form>

.prevent修饰符告诉v-on指令对于触发事件调用event.prevent()

==============================================
过滤器
只能应用于以下
{{message | capitalize}}
<div v-bind:id="rawId | formatID"></div>

new Vue({
	//...
	filters: {
		capitalize:function(value) {
			if(!value) return''
			value = value.toString()
			return value.charAt(0).toUpperCase()+value.slice(1)
		}
	}
})

================================================
缩写
v-bind 缩写
<a v-bind:href="url"></a>
==>
<a :href="url"></a>

v-on 缩写
<a v-on:click="doSomething"></a>
<a @:click="doSomething"></a>

===============================================
计算属性

不推荐直接在模版中放入太多逻辑,例
<div id="example">
	{{message.split('').reverse().join('') }}
</div>

--------------------------------------------
基础例子
<div id="example">
	<p>Original message:'{{message}}'</p>
	<p>Computed reversed message:"{{reversedMessage}}"
</div>

ver vm = new Vue({
	el:"example",
	data:{
		message:"Hello",
	},
	computed: {
		reversedMessage:function(){
			return this.message.split('').reverse().join('')
		}
	}
})

-------------------------------------------------
计算属性vsWatched Property
Vue.js提供方法$watch 用于观察Vue实例上的数据变动
<div id="demo">{{fullName}}</div>

var vm = new Vue({
	el: '#demo',
	data: {
		firstName: 'Foo',
		lastName: 'bar',
		fullName: 'Foo Bar'
	},
	watch: {
		firstName: function(val) {
			this.fullName = val + '' +this.lastName;
		},
		lastName: function(val) {
			this.fullName = this.firstName + '' +val
		}
	}
})

上面代码是命令式的和重复的。跟计算属性对比:

var vm = new Vue({
	el: '#demo',
	data: {
		firstName: 'Foo',
		lastName: 'Bar'
	},
	computed: {
		fullName: function() {
			return this.firstName + '' + this.lastName;
		}
	}
})

----------------------------------------------
计算setter
计算属性默认只有getter 不过在需要时你也可以提供一个setter：

//...
computed: {
	fullName: {
		get:function () {
			return this.firstName + '' +this.lastName;
		}
		//setter
		set: function(newValue) {
			var names = newValue.split('');
			this.firstName = names[0];
			this.lastName = names[names.length - 1];
		}
	}
}

现在运行vm.fullName = 'John Doe'时，setter会被调用，
vm.firstName和vm.lastName也会被相应更新

===============================================
观察Watchers

例
<div id="watch-example">
	<p>
		Ask a yes/no question:
		<input v-model="question">
	</p>
	<p>{{answer}}</p>
</div>

<script src="https://unpkg.com/axios@0.12.0/dist/axios.min.js"></script>
<script src="https://unpkg.com/lodash@4.13.1/lodash.min.js"></script>
<script>
var watchExampleVM = new Vue({
	el: '#watch-example',
	data: {
		question: '',
		answer: 'I cannot give you an answer until you ask a question'
	},
	watch: {
		// 如果question发生改变，这个函数就会运行
		question: function (newQuestion) {
			this.answer = "Waitting for you to stop typing...";
			this.getAnswer();
		}
	},
	methods: {

	}
})
</script>
